/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: title   start ]
Funciones genéricas
   [wxMaxima: title   end   ] */
/* [wxMaxima: fold    start ] */
/* [wxMaxima: input   start ] */
parsearRaices(_raices) := block(
    /* Dado [x=-1] devuelve [-1] (para cualquier longitud)*/
    ret : [],
    for i:1 thru length(_raices) do(
        push(rhs(_raices[i]), ret)    
    ),

    return(reverse(ret))
)$
parsearRaices([x=-1,x=3]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: fold    end   ] */

/* [wxMaxima: fold    end   ] */


/* [wxMaxima: title   start ]
Tema 1
   [wxMaxima: title   end   ] */


/* [wxMaxima: section start ]
Bisección
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
bisec(_f, _a, _b, _epsilon):= block(
    x : float((_a+_b)/2),

    /* Comprobación inicial */
    if _f(_a)*_f(_b) > 0 then
        return("Error: Precondición bisección no cumplida (f(a)*f(b)<0)."),

    /* Algoritmo */
    if _f(_a)=0 then
        return(_a)
    else if _f(_b)=0 then
        return(_b)
    else if _f(x)=0 or (abs(x-_a) < _epsilon) then
       return(x),    

    if _f(_a)*_f(x) < 0 then 
        return( bisec(_f, _a, x, _epsilon) )
    else    
        return( bisec(_f, x, _b, _epsilon) ) 
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
g(x) := x^2+1$
f(x) := %e^x-cos(x)$
bisec(g, 0, 2.2, 0.001);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Regula falsi
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
regulaFalsi(_f, _a, _b, _epsilon) := block(
    /* Comprobación inicial */
    if _f(_a)=_f(_b) then
        return("Error: Imposible definir siguiente iteración.")
    else
        x : float(_b - ((_b-_a)*_f(_b))/(_f(_b)-_f(_a))),

    /* Algoritmo */
    if _f(x)=0 or (abs(x-_a) < _epsilon) then 
        return(x),

    if _f(x)*_f(_a) < 0 then 
        return( regulaFalsi(_f, _a, x, _epsilon) )
    else
        return( regulaFalsi(_f, x, _b, _epsilon) )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(x):= x^2-1$
regulaFalsi(f, 0, 2, 0.00001);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Secante
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
secante(_f, _a, _b, _epsilon) := block(
    /* Comprobamos condición */
    if _f(_a)=_f(_b) then 
        return("Error: Imposible definir siguiente iteración.")
    else
        x : float(_b - ((_b-_a)*_f(_b))/(_f(_b)-_f(_a))),

    if _f(x)=0 or (abs(x-_b) < _epsilon) then 
        return(x)
    else
return(secante(_f, _b, x, _epsilon))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(x):= x^2-1$
secante(f, 0, 3, 0.1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Newton-Ralphson
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
newtonR(_f, _x_0, _epsilon) := block(
    kill(x, df),
    /* Definiciones */
    define(df(x), diff(_f(x), x)), /* Definiendo primera derivada */
    err : _epsilon+1,
    x_i : _x_0,
    nuevo_x : x_i,
    c_error : 0, /* Código de error */

    for i:0 step 1 while err > _epsilon and c_error=0 do block(
        if df(x_i)=0 then
            c_error : 1
        else
            nuevo_x : float(x_i - _f(x_i)/df(x_i)),

        err : abs(nuevo_x-x_i),
        x_i : nuevo_x,
        if i>10000 then
            c_error : 2
    ),

    if c_error=1 then
        return("Error: La derivada se anula, no es posible definir la siguiente iteración.") 
    else if c_error=2 then
        return("No encontrado.")
    else
        return(x_i)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(x):= x^2-1$
h(x) := %e^x-cos(x)$
newtonR(f, 0, 0.1);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Raíces
   [wxMaxima: section end   ] */


/* [wxMaxima: subsect start ]
Coeficientes polinomio
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
coeficientes(_p) := block(
    list : [],
    for i:0 thru hipow(_p(x),x) do(
        push(coeff(_p(x),x,i), list)
  ),
  return(list) 
)$
p(x) := x^4 + 2*x^3 − 3*x^2 − 4*x − 1;
coeficientes(p);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Sucesión de Sturm
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
raicesSimples(_p) := block(
    define(dp(x), diff(_p(x),x)),
    gcd_p_dp : gcd(_p(x), dp(x)),
    return(divide(_p(x), gcd_p_dp)[1])
)$
p(x) := (x-2)*(x-3)^2;
raicesSimples(p);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
sucSturm(_p) := block(
    v : matrix([_p(x)]),
    f_i : _p(x),
    define(dp(x),diff(_p(x),x)),
    f_ii : dp(x), 
    v : addrow(v, [f_ii]),
    fin : false,
    k : 2,

    while fin=false do(
        f_iii : -divide(f_i,f_ii)[2], /* Resto de la división */
        v : addrow(v, [f_iii*denom(f_iii)]),
        f_i : f_ii,
        f_ii : f_iii,
        k : k+1,
        if hipow(f_iii, x)=0 then
            fin : true  
    ),

    if v[k]=0 then(
        k : k-1,
        for i:0 thru k do(
            v[i] : divide(v[i],v[k])[1]
        )

    ),

    return(v)
)$
p(x) := x^4 + 2*x^3 − 3*x^2 − 4*x − 1$
s : sucSturm(p);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cambiosSigno(_sucS, _puntos) := block(
    /* Generando primera columna */
    mat : matrix([" "]),
    for i:1 thru length(_sucS) do(
        mat : addrow(mat, _sucS[i])
    ),


    /* Generando cambios de signo */
    for j:1 thru length(_puntos) do(
        vals : matrix([_puntos[j]]),
        for i:1 thru length(_sucS) do(
            val : ev(_sucS[i],x=_puntos[j])[1],
            letra : "0",
            if val>0 then
                letra : "+"
            else if val<0 then
                letra : "-",
            vals : addrow(vals, [letra])        
        ),
        mat : addcol(mat, vals)
    ),

    /* Contando cambios de signo */
    r_cambios : ["Cambios de signo:"],
    for j:1 thru length(_puntos) do(
 n_cambios : 0,
        anterior : mat[2][j+1],
        for i:2 thru length(_sucS) do(
            if is(equal(anterior, mat[i+1][j+1]))=false then (
                if is(equal("0", mat[i+1][j+1]))=false then(
                    n_cambios : n_cambios+1,
                    anterior : mat[i+1][j+1]
                )
            )
        ),
        push(n_cambios, r_cambios)
    ),
    mat : addrow(mat, reverse(r_cambios)),

    return(mat)
)$
p(x) := x^4 + 2*x^3 − 3*x^2 − 4*x − 1$
s : sucSturm(p)$
cambiosSigno(s,[-3,-1,-0.5,0,3]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Sistemas no lineales
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
eliminarSubarrays(_matrix, _i, _j) := block(
    ret : genmatrix(lambda([i,j], 0), _i, _j),
    for i:1 thru _i do(
        for j:1 thru _j do
            ret[i][j] : _matrix[i][j][1]            
    ),
    return(ret)
)$
newtonSistemas(_f, _x_0, _n_it) := block(
    /* Precondición: _x_0 vector columna */
    kill(x,y),
    jf : jacobian(_f(x,y), [x,y]),
    x_i : _x_0,
    
    for i:1 thru _n_it do(
        jf1 : ev(jf, [x=x_i[1][1], y=x_i[2][1]]),
        y_i : invert(jf1).eliminarSubarrays(transpose(_f(x_i[1], x_i[2])), 2, 1),
        x_i : float(x_i - y_i)
    ),

    return(x_i)
)$
f(x,y) := [0.3*sin(x)+0.4*cos(y), 0.3*cos(x)-0.4*sin(y)]$
newtonSistemas(f, transpose([0,0]), 100);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: title   start ]
Tema 2
   [wxMaxima: title   end   ] */


/* [wxMaxima: section start ]
Interpolación de polinomios
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
baseLagrange(_nodos) := block(
    n : length(_nodos),
    base : makelist(1,i,1,n),
    for i:1 thru n do(   
        for j:1 thru n do(
            if (i#j) then 
                base[i] : base[i]*(x-_nodos[j])/(_nodos[i]-_nodos[j]) 
        )
    ),
    return(base)
)$
baseLagrange([1,2,3]);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Lagrange(_f, _nodos) := block(
    n : length(_nodos), 
    base : baseLagrange(_nodos),
    p : 0,

    for i:1 thru n do
        p : p + _f(_nodos[i])*base[i],

    return(p)
)$
f(x) := x^2$
nodos : [1, 3, 5]$
ff : Lagrange(f, nodos);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
difDiv(_f, _nodos) := block(
    if length(_nodos)=1 then
        return(_f(_nodos[1]))
    else(
        /* Sin el último nodo */
        f1 : rest(_nodos,-1),

        /* Sin el primer nodo */
   f2 : _nodos,
        pop(f2),

        num : (difDiv(_f, f1) - difDiv(_f, f2)),
        den : (_nodos[1] - _nodos[length(_nodos)]),

        return(float(num/den))
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
Newton(_f, _nodos) := block(
    n : length(_nodos), 
    base : makelist(1,i,1,n),

    for i:1 thru n do(   
        for j:1 thru (i-1) do(
            base[i] : base[i]*(x-_nodos[j]) 
        )
    ),

    p : 0,
    nuevos_nodos : [_nodos[1]],
    for i:2 thru n do(
     /* Añadir nodo al final de nuevos_nodos */
        aux : reverse(nuevos_nodos),
        nuevos_nodos : push(_nodos[i], aux),
        nuevos_nodos : reverse(nuevos_nodos),

        /* Añadir sumando */
        p : p + difDiv(_f, nuevos_nodos)*base[i]
    ),

    return(p)
)$
f(x) := x^2$
nodos : [1, 3, 5]$
Newton(f, nodos);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Derivación numérica
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
derivacionNumerica(_f, _c, _ptos) := block(
    return(derivacionNumericaN(_f,_c,_ptos,1))
)$
derivacionNumericaN(_f, _c, _ptos, _n_der) := block(
    define(p(c), ev(Lagrange(_f, _ptos), x=c)),
    define(dp(x), diff(p(x),x,_n_der)),
    return(float(dp(_c)))
)$
derivacionNumerica(sin,0,makelist(-1+i*0.1,i,20));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Coeficientes indeterminados: 
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
x_0 : 1$
x_1 : 5$
x_2 : 7$
ec : [0=a_0+a_1+a_2, 1=a_0*x_0+a_1*x_1+a_2*x_2, 2*c=a_0*x_0^2+a_1*x_1^2+a_2*x_2^2]$
sol_r : solve(ec, [a_0,a_1,a_2])[1];
/* Parseamos las soluciones: */
sol : [rhs(sol_r[1]), rhs(sol_r[2]), rhs(sol_r[3])];
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Integración numérica
   [wxMaxima: section end   ] */


/* [wxMaxima: subsect start ]
Newton-Cotes cerradas
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
trapecio(_f, _a, _b) := block(
    return((b-a)/2*(_f(_a)+_f(_b)))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
simpson(_f, _a, _b) := block(
    return((_b-_a)/6*( _f(_a)+4*_f((_a+_b)/2)+_f(_b) ))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
newtonCotesC(_f, _nodos) := block(
    if length(_nodos)>=2 then(
        a : _nodos[1],
        b : _nodos[length(_nodos)],
        base : baseLagrange(_nodos),
        ret : 0,

        for i:1 thru length(_nodos) do(
            ret : ret + integrate(base[i],x,a,b)*_f(_nodos[i])
        )
    )
    else
        ret : "Error: Necesarios al menos dos nodos",

    return(ret)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Newton-Cotes abiertas
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
puntoMedio(_f, _a, _b) := block(
    return(_f((_a+_b)/2)*(_b-_a)/2)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: subsect start ]
Cuadratura Gaussiana
   [wxMaxima: subsect end   ] */


/* [wxMaxima: input   start ] */
polinomioLegendre(_n) := block(
    /* Usamos la fórmula de Rodrigues */
    define(derivada(x), diff((x^2-1)^(_n), x, _n)),
    polinomio(x) := 1/(2^(_n)*(_n!))*derivada(x),
    return(polinomio(x)/(2/(2*_n+1)))
)$
define(pol_n(c),  ev(polinomioLegendre(4), x=c));
allroots(pol_n(x));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
cuadraturaGaussiana(_ff, _a, _b, _n) := block( 
    /* Precondición: Requiere parsearRaices() y polinomioLegendre()

        Devuelve la integral de _f entre los puntos _a y _b 
    */

    /* Cambiar límites de integración */
    if _a#(-1) or _b#1 then
        _f(x) := _ff(((_b-_a)*x+(_b+_a))/2)*(_b-_a)/2
    else
        _f(x) := _ff(x),    

    /* Polinomios de Legendre */
    polinomio : polinomioLegendre(_n+1),
    define(polinomioL(x), ev(polinomio, x=x)),
    raices : parsearRaices(allroots(polinomio)),

    /* Pesos */
    pesos : [],
    define(derPolL(x), diff(polinomio,x)), /* Está mal definida */
    for i:1 thru length(raices) do(
        w_i : 1,
        for j:1 thru length(raices) do(
            if i#j then
                w_i : w_i * (x-raices[j])/(raices[i]-raices[j])            
        ),   
        w_i : integrate(w_i,x,-1,1),
        push(float(w_i), pesos)
    ),
    pesos : reverse(pesos),

    /* Calculando integral */
    valor : 0,
    for i:1 thru length(pesos) do
        valor : valor + pesos[i]*_f(raices[i]),

    return(float(valor))
)$
ratprint : false$ /* Oculta warnings */
cuadraturaGaussiana(sin,-2,1,2);
float(integrate(sin(x),x,-2,1));
/* [wxMaxima: input   end   ] */


/* [wxMaxima: title   start ]
Tema 3
   [wxMaxima: title   end   ] */


/* [wxMaxima: section start ]
Manejo errores PVI
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
erroresPVI(_valores, _a, _b, _f_orig) := block(
    if _a>=_b then
        return("Error: Punto final 'b' debe ser menor que 'a'.")
    else if length(_valores)=0 then
        return("Error: Valores debe ser una lista no vacía.")
    else(
        n : length(_valores),
        h : (_b-_a)/(n-1),
        mat : matrix(["Base", "Imagen", "Aproximación", "Error"]), 
        
        for i:1 thru n do(
            t_j : _a+(i-1)*h,
            mat : addrow(mat, [float(t_j), float(_f_orig(t_j)), _valores[i], float(abs(_f_orig(t_j)-_valores[i]))])
        ),
        
        return(mat)
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Método de Euler
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
metodoEuler(_f, _y_0, _a, _b, _n_iteraciones) := block(
    if _a>=_b then
        return("Error: Punto final 'b' debe ser menor que 'a'.")
    else(
        u_j : _y_0,
        h : (_b-_a)/_n_iteraciones,
        lista : [u_j],

        for j:1 thru _n_iteraciones do block(
            t_j : _a+j*h,
            u_j : u_j+h*_f(t_j,u_j),
            lista : push(float(u_j), lista)  
        ),
        
        return(reverse(lista))
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := -y+t+1$
f_orig(t) := t+%e^(-t)$
val : metodoEuler(f, 1, 0, 1, 10)$
erroresPVI(val, 0, 1, f_orig);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Consideramos entonces el siguiente método de Runge-Kutta de orden 2, llamado método de Euler mejorado:
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
EulerMejorado(_f, _y_0, _a, _b, _n_iteraciones) := block(
    u_j : _y_0,
    h : (_b-_a)/_n_iteraciones,
    lista : [u_j],
    for j:1 thru _n_iteraciones do(
        t_j : _a+j*h,
        u_j : u_j+h*_f(t_j+h/2, u_j+h/2*_f(t_j,u_j)),
        lista : push(float(u_j), lista)
    ),

    return(reverse(lista))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := -y+t+1$
f_orig(t) := t+%e^(-t)$
val : EulerMejorado(f, 1, 0, 1, 10)$
erroresPVI(val, 0, 1, f_orig);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Método de Taylor
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
T_r(_t, _y, _f, _h, _r) := block(
    /* Devuelve un valor en un punto concreto (_t,_y) */
    ret : _f(_t,_y),
    define(dfdt(x,s), diff(_f(x,s), x, 1)),
    define(dfdy(x,s), diff(_f(x,s), s, 1)),
    lim : (_r-1),
    
    for i:1 thru lim do block(
        f_s : dfdt(_t,_y) + dfdy(_t,_y)*_f(_t,_y),
        define(dfdt(x,s), diff(dfdt(x,s), x, 1)),
        define(dfdy(x,s), diff(dfdt(x,s), s, 1)),
        ret : ret + _h^i/(i+1)!*f_s
    ),

    /*return(_f(_t, _y) + h/2*(dfdt(_t, _y)+dfdy(_t, _y)*_f(_t, _y)))*/
    return(ret)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
metodoTaylor(_f, _y_0, _a, _b, _n, _r) := block(
    h : (_b-_a)/_n,
    lista : [_y_0],
    
    for j:1 thru _n do block(
        t_j : _a+h*j,
        u_j : lista[j], /* Coge la posición anterior */
        u : u_j + h*T_r(t_j, u_j, _f, h, _r),
        lista : push(float(u), lista)
    ),
    
    return(reverse(lista))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := y^2/(1+t)$
f_orig(t) := float(-1/log(t+1))$
val : metodoTaylor(f, float(f_orig(1)), 1, 2, 10, 2)$
erroresPVI(val, 1, 2, f_orig);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Método del punto medio
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
metodoPuntoMedio(_f, _y_0, _y_1, _a, _b, _n_iteraciones) := block(
    u_j_1 : _y_0, /* u_j menos uno*/
    u_j : _y_1,
    h : (_b-_a)/_n_iteraciones,
    lista : [u_j_1, u_j], /* Al reves para luego girar */
    
    for j:2 thru _n_iteraciones do block(
        t_j : float(_a+j*h),
        
        /* Calculamos iteración */
        u_j_n : u_j_1 + 2*h*_f(t_j, u_j), /* Nuevo valor */
        
        /* Actualizamos valores */
        u_j_1 : u_j,
        u_j : u_j_n,
        
        lista : push(float(u_j), lista)
    ),
    
    return(reverse(lista))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := -y+t+1$
f_orig(t) := t+%e^(-t)$
val : metodoPuntoMedio(f, f_orig(0), f_orig(0.1), 0, 1, 10)$
erroresPVI(val, 0, 1, f_orig);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Método de Simpson
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
metodoSimpson(_f, _y_0, _y_1, _a, _b, _n_iteraciones) := block(
    u_j_1 : _y_0, /* u_j menos uno*/
    u_j : _y_1,
    h : (_b-_a)/_n_iteraciones,
    lista : [u_j, u_j_1], /* Al reves para luego girar */
    
    for j:2 thru _n_iteraciones do block(
        t_j_1 : float(_a+(j-2)*h),
        t_j   : float(_a+(j-1)*h),
        t_j_n : float(_a+j*h),
        
        /* Calculamos iteración */
        aux(u_j_n) := -u_j_n +  u_j_1 + +h/3*(_f(t_j_1,u_j_1) + 4*_f(t_j,u_j) + _f(t_j_n,u_j_n)), /* Nuevo valor */
        u_j_n : float(rhs(solve([aux(x)=0], [x])[1])),
        
        /* Actualizamos valores */
        u_j_1 : u_j,
        u_j : u_j_n,
        lista : push(float(u_j), lista)
    ),
    
    return(reverse(lista))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := -y+t+1$
f_orig(t) := t+%e^(-t)$
val : metodoSimpson(f, f_orig(0), f_orig(0.1), 0, 1, 10)$
erroresPVI(val, 0, 1, f_orig);
/* [wxMaxima: input   end   ] */


/* [wxMaxima: section start ]
Método del trapecio o Crank-Nicholson
   [wxMaxima: section end   ] */


/* [wxMaxima: input   start ] */
metodoTrapecio(_f, _y_0, _a, _b, _n_iteraciones) := block(
    ratprint : false,
    u_j : _y_0,
    h : (_b-_a)/_n_iteraciones,
    lista : [u_j],
    
    for j:1 thru _n_iteraciones do(
        t_j   : float(_a+(j-1)*h),
        t_j_1 : float(_a+j*h),
        
        /* Obtenemos el siguiente elemento */
        aux(u_j_1) := -u_j_1 + u_j + h/2*( _f(t_j,u_j) + _f(t_j_1,u_j_1) ),
        u_j_1 : float(rhs(solve([aux(x)=0], [x])[1])),
        
        /* Actualizamos */
        u_j : u_j_1,
        lista : push(float(u_j), lista)
    ),

    return(reverse(lista))
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: input   start ] */
f(t,y) := -y+t+1$
f_orig(t) := t+%e^(-t)$
val : metodoTrapecio(f, f_orig(0), 0, 1, 10);
erroresPVI(val, 0, 1, f_orig);
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
